var _aes_tables = new Uint8Array([
    // 0x0000: Sbox
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,

    // 0x0100: InvSbox
    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,

    // 0x0200: 2 × Sbox[X]
    0xc6, 0xf8, 0xee, 0xf6, 0xff, 0xd6, 0xde, 0x91, 0x60, 0x02, 0xce, 0x56, 0xe7, 0xb5, 0x4d, 0xec,
    0x8f, 0x1f, 0x89, 0xfa, 0xef, 0xb2, 0x8e, 0xfb, 0x41, 0xb3, 0x5f, 0x45, 0x23, 0x53, 0xe4, 0x9b,
    0x75, 0xe1, 0x3d, 0x4c, 0x6c, 0x7e, 0xf5, 0x83, 0x68, 0x51, 0xd1, 0xf9, 0xe2, 0xab, 0x62, 0x2a,
    0x08, 0x95, 0x46, 0x9d, 0x30, 0x37, 0x0a, 0x2f, 0x0e, 0x24, 0x1b, 0xdf, 0xcd, 0x4e, 0x7f, 0xea,
    0x12, 0x1d, 0x58, 0x34, 0x36, 0xdc, 0xb4, 0x5b, 0xa4, 0x76, 0xb7, 0x7d, 0x52, 0xdd, 0x5e, 0x13,
    0xa6, 0xb9, 0x00, 0xc1, 0x40, 0xe3, 0x79, 0xb6, 0xd4, 0x8d, 0x67, 0x72, 0x94, 0x98, 0xb0, 0x85,
    0xbb, 0xc5, 0x4f, 0xed, 0x86, 0x9a, 0x66, 0x11, 0x8a, 0xe9, 0x04, 0xfe, 0xa0, 0x78, 0x25, 0x4b,
    0xa2, 0x5d, 0x80, 0x05, 0x3f, 0x21, 0x70, 0xf1, 0x63, 0x77, 0xaf, 0x42, 0x20, 0xe5, 0xfd, 0xbf,
    0x81, 0x18, 0x26, 0xc3, 0xbe, 0x35, 0x88, 0x2e, 0x93, 0x55, 0xfc, 0x7a, 0xc8, 0xba, 0x32, 0xe6,
    0xc0, 0x19, 0x9e, 0xa3, 0x44, 0x54, 0x3b, 0x0b, 0x8c, 0xc7, 0x6b, 0x28, 0xa7, 0xbc, 0x16, 0xad,
    0xdb, 0x64, 0x74, 0x14, 0x92, 0x0c, 0x48, 0xb8, 0x9f, 0xbd, 0x43, 0xc4, 0x39, 0x31, 0xd3, 0xf2,
    0xd5, 0x8b, 0x6e, 0xda, 0x01, 0xb1, 0x9c, 0x49, 0xd8, 0xac, 0xf3, 0xcf, 0xca, 0xf4, 0x47, 0x10,
    0x6f, 0xf0, 0x4a, 0x5c, 0x38, 0x57, 0x73, 0x97, 0xcb, 0xa1, 0xe8, 0x3e, 0x96, 0x61, 0x0d, 0x0f,
    0xe0, 0x7c, 0x71, 0xcc, 0x90, 0x06, 0xf7, 0x1c, 0xc2, 0x6a, 0xae, 0x69, 0x17, 0x99, 0x3a, 0x27,
    0xd9, 0xeb, 0x2b, 0x22, 0xd2, 0xa9, 0x07, 0x33, 0x2d, 0x3c, 0x15, 0xc9, 0x87, 0xaa, 0x50, 0xa5,
    0x03, 0x59, 0x09, 0x1a, 0x65, 0xd7, 0x84, 0xd0, 0x82, 0x29, 0x5a, 0x1e, 0x7b, 0xa8, 0x6d, 0x2c,

    // 0x0300: 3 × Sbox[X]
    0xa5, 0x84, 0x99, 0x8d, 0x0d, 0xbd, 0xb1, 0x54, 0x50, 0x03, 0xa9, 0x7d, 0x19, 0x62, 0xe6, 0x9a,
    0x45, 0x9d, 0x40, 0x87, 0x15, 0xeb, 0xc9, 0x0b, 0xec, 0x67, 0xfd, 0xea, 0xbf, 0xf7, 0x96, 0x5b,
    0xc2, 0x1c, 0xae, 0x6a, 0x5a, 0x41, 0x02, 0x4f, 0x5c, 0xf4, 0x34, 0x08, 0x93, 0x73, 0x53, 0x3f,
    0x0c, 0x52, 0x65, 0x5e, 0x28, 0xa1, 0x0f, 0xb5, 0x09, 0x36, 0x9b, 0x3d, 0x26, 0x69, 0xcd, 0x9f,
    0x1b, 0x9e, 0x74, 0x2e, 0x2d, 0xb2, 0xee, 0xfb, 0xf6, 0x4d, 0x61, 0xce, 0x7b, 0x3e, 0x71, 0x97,
    0xf5, 0x68, 0x00, 0x2c, 0x60, 0x1f, 0xc8, 0xed, 0xbe, 0x46, 0xd9, 0x4b, 0xde, 0xd4, 0xe8, 0x4a,
    0x6b, 0x2a, 0xe5, 0x16, 0xc5, 0xd7, 0x55, 0x94, 0xcf, 0x10, 0x06, 0x81, 0xf0, 0x44, 0xba, 0xe3,
    0xf3, 0xfe, 0xc0, 0x8a, 0xad, 0xbc, 0x48, 0x04, 0xdf, 0xc1, 0x75, 0x63, 0x30, 0x1a, 0x0e, 0x6d,
    0x4c, 0x14, 0x35, 0x2f, 0xe1, 0xa2, 0xcc, 0x39, 0x57, 0xf2, 0x82, 0x47, 0xac, 0xe7, 0x2b, 0x95,
    0xa0, 0x98, 0xd1, 0x7f, 0x66, 0x7e, 0xab, 0x83, 0xca, 0x29, 0xd3, 0x3c, 0x79, 0xe2, 0x1d, 0x76,
    0x3b, 0x56, 0x4e, 0x1e, 0xdb, 0x0a, 0x6c, 0xe4, 0x5d, 0x6e, 0xef, 0xa6, 0xa8, 0xa4, 0x37, 0x8b,
    0x32, 0x43, 0x59, 0xb7, 0x8c, 0x64, 0xd2, 0xe0, 0xb4, 0xfa, 0x07, 0x25, 0xaf, 0x8e, 0xe9, 0x18,
    0xd5, 0x88, 0x6f, 0x72, 0x24, 0xf1, 0xc7, 0x51, 0x23, 0x7c, 0x9c, 0x21, 0xdd, 0xdc, 0x86, 0x85,
    0x90, 0x42, 0xc4, 0xaa, 0xd8, 0x05, 0x01, 0x12, 0xa3, 0x5f, 0xf9, 0xd0, 0x91, 0x58, 0x27, 0xb9,
    0x38, 0x13, 0xb3, 0x33, 0xbb, 0x70, 0x89, 0xa7, 0xb6, 0x22, 0x92, 0x20, 0x49, 0xff, 0x78, 0x7a,
    0x8f, 0xf8, 0x80, 0x17, 0xda, 0x31, 0xc6, 0xb8, 0xc3, 0xb0, 0x77, 0x11, 0xcb, 0xfc, 0xd6, 0x3a,

    // 0x0400: 9 × X
    0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
    0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
    0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
    0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
    0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
    0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
    0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
    0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
    0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
    0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
    0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
    0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
    0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
    0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
    0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
    0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46,

    // 0x0500: 11 × X
    0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
    0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
    0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
    0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
    0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
    0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
    0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
    0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
    0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
    0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
    0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
    0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
    0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
    0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
    0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
    0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3,

    // 0x0600: 13 × X
    0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
    0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
    0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
    0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
    0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
    0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
    0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
    0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
    0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
    0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
    0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
    0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
    0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
    0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
    0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
    0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97,

    // 0x0700: 14 × X
    0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
    0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
    0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
    0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
    0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
    0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
    0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
    0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
    0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
    0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
    0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
    0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
    0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
    0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
    0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
    0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d,

    // 0x0800: processed data
]);

var _aes_heap_start = 0x800; // multiple of 16

var _aes_block_size = 16;

var _aes_zero_iv = new Uint8Array(_aes_block_size);

function _aes_constructor ( key, options ) {
    options = options || {};
    options.heapSize = options.heapSize || 4096;

    if ( options.heapSize <= 0 || options.heapSize % 4096 )
        throw new IllegalArgumentError("heapSize must be a positive number and multiple of 4096");

    this.BLOCK_SIZE = _aes_block_size;
    this.KEY_SIZE   = 16; // TODO support of 192- and 256-bit keys

    this.heap = new Uint8Array(options.heapSize);
    this.heap.set(_aes_tables);

    this.asm = aes_asm( global, null, this.heap.buffer );

    this.key = null;

    this.result = null;

    this.reset( key, options );
}

function _aes_reset ( key ) {
    this.result = null;

    var asm = this.asm;

    if ( key !== undefined ) {
        if ( key instanceof ArrayBuffer || key instanceof Uint8Array ) {
            key = new Uint8Array(key);
        }
        else if ( typeof key === 'string' ) {
            var str = key;
            key = new Uint8Array(str.length);
            for ( var i = 0; i < str.length; ++i )
                key[i] = str.charCodeAt(i);
        }
        else {
            throw new TypeError("expected key type");
        }

        if ( key.length !== this.KEY_SIZE )
            throw new IllegalArgumentError("illegal key size");

        this.key = key;

        asm.init_key_128.apply( asm, key );
    }

    return this;
}

function _aes_init_iv ( iv ) {
    var asm = this.asm;

    if ( iv !== undefined ) {
        if ( iv instanceof Uint8Array || iv instanceof ArrayBuffer ) {
            iv = new Uint8Array(iv);
        }
        else if ( typeof iv === 'string' ) {
            var str = iv;
            iv = new Uint8Array(str.length);
            for ( var i = 0; i < str.length; ++i )
                iv[i] = str.charCodeAt(i);
        }
        else {
            throw new TypeError("unexpected iv type");
        }

        if ( iv.length !== _aes_block_size )
            throw new IllegalArgumentError("illegal iv size");

        this.iv = iv;
        asm.init_state.apply( asm, iv );
    }
    else {
        this.iv = null;
        asm.init_state.apply( asm, _aes_zero_iv );
    }
}

function _aes_heap_write ( heap, hpos, data, dpos, dlen ) {
    var hlen = heap.byteLength - hpos,
        wlen = (hlen < dlen) ? hlen : dlen;

    if ( data instanceof ArrayBuffer || data instanceof Uint8Array ) {
        heap.set( new Uint8Array( (data.buffer||data), dpos, wlen ), hpos );
    }
    else if ( typeof data === 'string' ) {
        for ( var i = 0; i < wlen; ++i ) heap[ hpos + i ] = data.charCodeAt( dpos + i );
    }
    else {
        throw new TypeError("unexpected data type");
    }

    return wlen;
}

/**
 * Cipher-block chaining (CBC)
 */

function cbc_aes_constructor ( key, options ) {
    this.padding = true;
    this.mode = 'cbc';
    this.iv = null;

    _aes_constructor.call( this, key, options );
}

function cbc_aes_reset ( key, options ) {
    options = options || {};

    _aes_reset.call( this, key, options );

    var padding = options.padding;
    if ( padding !== undefined ) {
        this.padding = !!padding;
    } else {
        this.padding = true;
    }

    _aes_init_iv.call( this, options.iv );

    return this;
}

function cbc_aes_encrypt ( data ) {
    if ( !this.key )
        throw new IllegalStateError("no key is associated with the instance");

    var dpos = data.byteOffset || 0,
        dlen = data.byteLength || data.length || 0,
        asm = this.asm,
        heap = this.heap,
        padding = this.padding,
        rlen = _aes_block_size * Math.ceil( dlen / _aes_block_size ),
        wlen = 0;

    if ( dlen % _aes_block_size === 0 ) {
        if ( padding ) rlen += _aes_block_size;
    }
    else if ( !padding ) {
        throw new IllegalArgumentError("data length must be a multiple of " + _aes_block_size);
    }

    var result = new Uint8Array(rlen);

    padding = dlen < rlen;
    rlen = 0;
    while ( dlen >= _aes_block_size ) {
        wlen = _aes_heap_write( heap, _aes_heap_start, data, dpos, dlen );
        dpos += wlen;
        dlen -= wlen;

        asm.cbc_encrypt.call( asm, _aes_heap_start, wlen );

        result.set( heap.subarray( _aes_heap_start, _aes_heap_start + wlen ), rlen );
        rlen += wlen;
    }
    if ( padding ) {
        wlen = _aes_heap_write( heap, _aes_heap_start, data, dpos, dlen );

        var plen = _aes_block_size - wlen % _aes_block_size;
        for ( var p = 0; p < plen; ++p ) heap[ _aes_heap_start + wlen + p ] = plen;
        wlen += plen;

        asm.cbc_encrypt.call( asm, _aes_heap_start, wlen );

        result.set( heap.subarray( _aes_heap_start, _aes_heap_start + wlen ), rlen );
    }

    this.result = result;

    return this;
}

function cbc_aes_decrypt ( data ) {
    if ( !this.key )
        throw new Error("Illegal state");

    var dpos = data.byteOffset || 0,
        dlen = data.byteLength || data.length || 0,
        asm = this.asm,
        heap = this.heap,
        padding = this.padding,
        rlen = 0,
        wlen = 0;

    if ( dlen % _aes_block_size !== 0 )
        throw new IllegalArgumentError("data length must be a multiple of " + _aes_block_size);

    var result = new Uint8Array(dlen);

    while ( dlen > 0 ) {
        wlen = _aes_heap_write( heap, _aes_heap_start, data, dpos, dlen );
        dpos += wlen;
        dlen -= wlen;

        asm.cbc_decrypt.call( asm, _aes_heap_start, wlen );

        result.set( heap.subarray( _aes_heap_start, _aes_heap_start + wlen ), rlen );
        rlen += wlen;
    }

    if ( padding ) {
        var pad = result[ rlen - 1 ];
        result = result.subarray( 0, rlen - pad );
    }

    this.result = result;

    return this;
}

var cbc_aes_prototype = cbc_aes_constructor.prototype;
cbc_aes_prototype.reset = cbc_aes_reset;
cbc_aes_prototype.encrypt = cbc_aes_encrypt;
cbc_aes_prototype.decrypt = cbc_aes_decrypt;

/**
 * Counter with CBC-MAC (CCM)
 *
 * Due to JS limitations (counter is 32-bit unsigned) maximum encrypted message length
 * is limited to ~64 GiB ( 2^36 - 16 ) per `nonce`-`key` pair. That also limits `lengthSize` parameter
 * maximum value to 5 (not 8 as described in RFC3610).
 *
 * Additional authenticated data `adata` maximum length is limited to 65279 bytes ( 2^16 - 2^8 ),
 * wich is considered enough for the wast majority of use-cases.
 *
 * And one more important thing: in case of progressive ciphering of a data stream (in other
 * words when data can't be held in-memory at a whole and are ciphered chunk-by-chunk)
 * you have to know the `dataLength` in advance and pass that value to the cipher options.
 */

function _cbc_mac_process ( data ) {
    var dpos = data.byteOffset || 0,
        dlen = data.byteLength || data.length || 0,
        wlen = 0;

    while ( dlen > 0 ) {
        wlen = _aes_heap_write( this.heap, _aes_heap_start, data, dpos, dlen );
        this.asm.cbc_mac( _aes_heap_start, wlen, -1 );
        dpos += wlen;
        dlen -= wlen;
    }
}

var _ccm_adata_maxLength = 65279,       // 2^16 - 2^8
    _ccm_data_maxLength = 68719476720;  // 2^36 - 2^4

function ccm_aes_constructor ( key, options ) {
    this.padding    = false;
    this.mode       = 'ccm';

    this.tagSize    = _aes_block_size;
    this.lengthSize = 4;

    this.nonce      = null;

    this.adata      = null;

    this.iv         = null;
    this.dataLength = -1;
    this.dataLeft   = -1;

    this.counter    = 1;

    _aes_constructor.call( this, key, options );
}

function _ccm_calculate_iv () {
    var nonce = this.nonce,
        adata = this.adata,
        tagSize = this.tagSize,
        lengthSize = this.lengthSize,
        dataLength = this.dataLength;

    var data = new Uint8Array( _aes_block_size + ( adata ? 2 + adata.byteLength : 0 ) );

    // B0: flags(adata?, M', L'), nonce, len(data)
    data[0] = ( adata ? 64 : 0 ) | ( (tagSize-2)<<2 ) | ( lengthSize-1 );
    data.set( nonce, 1 );
    if (lengthSize > 4) data[11] = ( ( dataLength - (dataLength>>>0) ) / 4294967296 )&15;
    if (lengthSize > 3) data[12] = dataLength>>>24;
    if (lengthSize > 2) data[13] = dataLength>>>16&255;
    data[14] = dataLength>>>8&255;
    data[15] = dataLength&255;

    // B*: len(adata), adata
    if ( adata ) {
        data[16] = adata.byteLength>>>8&255;
        data[17] = adata.byteLength&255;
        data.set( adata, 18 );
    }

    _cbc_mac_process.call( this, data );
    this.asm.save_state( _aes_heap_start );

    this.iv = new Uint8Array( this.heap.subarray( _aes_heap_start, _aes_heap_start + _aes_block_size ) );
}

function ccm_aes_reset ( key, options ) {
    options = options || {};

    _aes_reset.call( this, key, options );

    _aes_init_iv.call( this, options.iv );

    var tagSize = options.tagSize;
    if ( tagSize !== undefined ) {
        if ( typeof tagSize !== 'number' )
            throw new TypeError("tagSize must be a number");

        if ( tagSize < 4 || tagSize > 16 || tagSize & 1 )
            throw new IllegalArgumentError("illegal tagSize value");

        this.tagSize = tagSize;
    }
    else {
        this.tagSize = tagSize = _aes_block_size;
    }

    var lengthSize = options.lengthSize;
    if ( lengthSize !== undefined ) {
        if ( typeof lengthSize !== 'number' )
            throw new TypeError("lengthSize must be a number");

        if ( lengthSize < 2 || lengthSize > 5 )
            throw new IllegalArgumentError("illegal lengthSize value");

        this.lengthSize = lengthSize;
    }
    else {
        this.lengthSize = lengthSize = 4;
    }

    var nonce = options.nonce;
    if ( nonce !== undefined ) {
        if ( nonce instanceof Uint8Array || nonce instanceof ArrayBuffer ) {
            nonce = new Uint8Array(nonce);
        }
        else if ( typeof nonce === 'string' ) {
            var str = nonce;
            nonce = new Uint8Array(str.length);
            for ( var i = 0; i < str.length; ++i )
                nonce[i] = str.charCodeAt(i);
        }
        else {
            throw new TypeError("unexpected nonce type");
        }

        if ( nonce.length !== ( 15 - lengthSize ) )
            throw new IllegalArgumentError("illegal nonce length");

        this.nonce = nonce;
    }
    else {
        this.nonce = nonce = null;
    }

    var iv = this.iv;

    var counter = options.counter;
    if ( counter !== undefined ) {
        if ( iv === null )
            throw new IllegalStateError("iv is also required");

        if ( typeof counter !== 'number' )
            throw new TypeError("counter must be a number");

        this.counter = counter;
    }
    else {
        this.counter = counter = 1;
    }

    var dataLength = options.dataLength;
    if ( dataLength !== undefined ) {
        if ( typeof dataLength !== 'number' )
            throw new TypeError("dataLength must be a number");

        if ( dataLength < 0 || dataLength > _ccm_maxDataLength || dataLength > ( Math.pow( 2, 8*lengthSize ) - 1 ) )
            throw new IllegalArgumentError("illegal dataLength value");

        this.dataLength = dataLength;

        var dataLeft = options.dataLeft || dataLength;

        if ( typeof dataLeft !== 'number' )
            throw new TypeError("dataLeft must be a number");

        if ( dataLeft < 0 || dataLeft > dataLength )
            throw new IllegalArgumentError("illegal dataLeft value");

        this.dataLeft = dataLeft;
    }
    else {
        this.dataLength = dataLength = -1;
        this.dataLeft   = dataLength;
    }

    var adata = options.adata;
    if ( adata !== undefined ) {
        if ( iv !== null )
            throw new IllegalStateError("you must specify either adata or iv, not both");

        if ( adata instanceof ArrayBuffer || adata instanceof Uint8Array ) {
            adata = new Uint8Array(adata);
        }
        else if ( typeof adata === 'string' ) {
            var str = adata;
            adata = new Uint8Array(str.length);
            for ( var i = 0; i < str.length; ++i )
                adata[i] = str.charCodeAt(i);
        }
        else {
            throw new TypeError("unexpected adata type");
        }

        if ( adata.byteLength === 0 || adata.byteLength > _ccm_adata_maxLength )
            throw new IllegalArgumentError("illegal adata length");

        this.adata = adata;
        this.counter = counter = 1;
    }
    else {
        this.adata = adata = null;
    }

    if ( dataLength !== -1 )
        _ccm_calculate_iv.call(this);

    return this;
}

function ccm_aes_encrypt ( data ) {
    if ( !this.key )
        throw new IllegalStateError("no key is associated with the instance");

    var dpos = data.byteOffset || 0,
        dlen = data.byteLength || data.length || 0;

    if ( this.dataLength === -1 ) {
        this.dataLength = dlen;
        this.dataLeft = dlen;
    }

    var asm = this.asm,
        heap = this.heap,
        nonce = this.nonce,
        iv = this.iv,
        counter = this.counter,
        tagSize = this.tagSize,
        rlen = 0,
        wlen = 0;

    if ( ((counter-1)<<4) + dlen > _ccm_data_maxLength )
        throw new RangeError("counter overflow");

    if ( iv ) {
        asm.init_state.apply( asm, iv );
    } else {
        _ccm_calculate_iv.call(this);
    }

    var dleft = ( this.dataLeft -= dlen ),
        result = new Uint8Array( dlen + ( dleft > 0 ? 0 : tagSize ) );

    var asm_args = [ _aes_heap_start, 0, (this.lengthSize-1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    for ( var i = 0; i < nonce.length; ++i ) asm_args[3+i] = nonce[i];

    while ( dlen > 0 ) {
        wlen = _aes_heap_write( heap, _aes_heap_start, data, dpos, dlen );
        dpos += wlen;
        dlen -= wlen;

        var c = counter + (rlen>>>4);
        asm_args[1] = wlen;
        asm_args[16] = (c/0x100000000)>>>0;
        asm_args[17] = c>>>0;
        asm.ccm_encrypt.apply( asm, asm_args );

        result.set( heap.subarray( _aes_heap_start, _aes_heap_start + wlen ), rlen );
        rlen += wlen;
    }

    if ( dleft <= 0 ) {
        asm.save_state( _aes_heap_start );

        asm_args[1] = _aes_block_size,
        asm_args[16] = 0;
        asm_args[17] = 0;
        asm.ccm_encrypt.apply( asm, asm_args );

        result.set( heap.subarray( _aes_heap_start, _aes_heap_start + tagSize ), rlen );
    }

    this.result = result;

    return this;
}

function ccm_aes_decrypt ( data ) {
    if ( !this.key )
        throw new IllegalStateError("no key is associated with the instance");

    var dpos = data.byteOffset || 0,
        dlen = data.byteLength || data.length || 0,
        tagSize = this.tagSize;

    if ( this.dataLength === -1 ) {
        this.dataLength = dlen - tagSize;
        this.dataLeft = dlen;
    }

    var asm = this.asm,
        heap = this.heap,
        nonce = this.nonce,
        iv = this.iv,
        counter = this.counter,
        dleft = this.dataLeft,
        rlen = 0,
        wlen = 0;

    if ( dleft < tagSize )
        throw new RangeError("OMG WTF");

    if ( dleft <= dlen )
        dlen = dleft - tagSize;

    if ( ((counter-1)<<4) + dlen > _ccm_data_maxLength )
        throw new RangeError("counter overflow");

    if ( iv ) {
        asm.init_state.apply( asm, iv );
    } else {
        _ccm_calculate_iv.call(this);
    }

    dleft = ( this.dataLeft -= dlen );
    var result = new Uint8Array(dlen);

    var asm_args = [ _aes_heap_start, 0, (this.lengthSize-1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    for ( var i = 0; i < nonce.length; ++i ) asm_args[3+i] = nonce[i];

    while ( dlen > 0 ) {
        wlen = _aes_heap_write( heap, _aes_heap_start, data, dpos, dlen );
        dpos += wlen;
        dlen -= wlen;

        var c = counter + (rlen>>>4);
        asm_args[1] = wlen,
        asm_args[16] = (c/0x100000000)>>>0;
        asm_args[17] = c>>>0;
        asm.ccm_decrypt.apply( asm, asm_args );

        result.set( heap.subarray( _aes_heap_start, _aes_heap_start + wlen ), rlen );
        rlen += wlen;
    }

    if ( dleft === tagSize ) {
        asm.save_state( _aes_heap_start );
        asm_args[1] = _aes_block_size,
        asm_args[16] = 0;
        asm_args[17] = 0;
        asm.ccm_encrypt.apply( asm, asm_args );

        var atag = new Uint8Array(tagSize);
        _aes_heap_write( atag, 0, data, dpos, tagSize );

        var acheck = 0;
        for ( var i = 0; i < tagSize; ++i )
            acheck |= atag[i] ^ heap[ _aes_heap_start + i ];
        if ( acheck )
            throw new SecurityError("data integrity check failed");
    }

    this.result = result;

    return this;
}

var ccm_aes_prototype = ccm_aes_constructor.prototype;
ccm_aes_prototype.reset = ccm_aes_reset;
ccm_aes_prototype.encrypt = ccm_aes_encrypt;
ccm_aes_prototype.decrypt = ccm_aes_decrypt;

/**
 * Static constants & methods
 */

var aes_static = {};
aes_static.BLOCK_SIZE = _aes_block_size;

var cbc_aes_instance = new cbc_aes_constructor();
aes_static.encrypt = function ( data, key, options ) { if ( key === undefined ) throw new IllegalArgumentError("key is required"); return cbc_aes_instance.reset(key,options).encrypt(data).result; };
aes_static.decrypt = function ( data, key, options ) { if ( key === undefined ) throw new IllegalArgumentError("key is required"); return cbc_aes_instance.reset(key,options).decrypt(data).result; };

/**
 * Exports
 */

exports.AES = aes_static;
exports.CBC_AES = cbc_aes_constructor;
exports.CCM_AES = ccm_aes_constructor;
