<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>AES test suite</title>
<link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.12.0.css">
<script src="http://code.jquery.com/qunit/qunit-1.12.0.js"></script>
<script src="asmcrypto.js"></script>
</head>
<body>
<div id="qunit"></div>
<div id="qunit-fixture"></div>
<script>

test( "dummy test", function () {
    ok( true, "Passed!" );
});

///////////////////////////////////////////////////////////////////////////////

module("AES");

var aes_init_vectors = [
    [ 0x19, 0x3d, 0xe3, 0xbe, 0xa0, 0xf4, 0xe2, 0x2b, 0x9a, 0xc6, 0x8d, 0x2a, 0xe9, 0xf8, 0x48, 0x08 ]
];

test( "_init_state / _test_state", function () {
    var aes = new asmCrypto.AES('0123456789ABCDEF');
    for ( var i = 0; i < aes_init_vectors.length; ++i ) {
        aes.asm.init_state.apply( aes.asm, aes_init_vectors[i] );
        ok(
            aes.asm._test_state.apply( aes.asm, aes_init_vectors[i] ),
            "_init_state / _test_state vector " + i
        );
    }
});

test( "init_key_128 / _test_key_128", function () {
    var aes = new asmCrypto.AES('0123456789ABCDEF');
    for ( var i = 0; i < aes_init_vectors.length; ++i ) {
        aes.asm.init_key_128.apply( aes.asm, aes_init_vectors[i] );
        var args = [ i ]; args.push.apply( args, aes_init_vectors[i] );
        ok(
            aes.asm._test_key_128.apply( aes.asm, args ),
            "init_key_128 / _test_key_128 vector " + i
        );
    }
});

var aes_sub_shift_vectors = [
    [ [ 0x19, 0x3d, 0xe3, 0xbe, 0xa0, 0xf4, 0xe2, 0x2b, 0x9a, 0xc6, 0x8d, 0x2a, 0xe9, 0xf8, 0x48, 0x08 ],
      [ 0xd4, 0xbf, 0x5d, 0x30, 0xe0, 0xb4, 0x52, 0xae, 0xb8, 0x41, 0x11, 0xf1, 0x1e, 0x27, 0x98, 0xe5 ] ]
];

test( "_sub_shift / _inv_sub_shift", function () {
    var aes = new asmCrypto.AES('0123456789ABCDEF');
    for ( var i = 0; i < aes_sub_shift_vectors.length; ++i ) {
        aes.asm.init_state.apply( aes.asm, aes_sub_shift_vectors[i][0] );
        aes.asm._sub_shift();
        ok(
            aes.asm._test_state.apply( aes.asm, aes_sub_shift_vectors[i][1] ),
            "_sub_shift vector " + i
        );
        aes.asm._inv_sub_shift();
        ok(
            aes.asm._test_state.apply( aes.asm, aes_sub_shift_vectors[i][0] ),
            "_inv_sub_shift vector " + i
        );
    }
});

var aes_sub_shift_mix_vectors = [
    [ [ 0xaa, 0x8f, 0x5f, 0x03, 0x61, 0xdd, 0xe3, 0xef, 0x82, 0xd2, 0x4a, 0xd2, 0x68, 0x32, 0x46, 0x9a ],
      [ 0x75, 0xec, 0x09, 0x93, 0x20, 0x0b, 0x63, 0x33, 0x53, 0xc0, 0xcf, 0x7c, 0xbb, 0x25, 0xd0, 0xdc ] ]
];

test( "_sub_shift_mix / _inv_sub_shift_mix", function () {
    for ( var i = 0; i < aes_sub_shift_mix_vectors.length; ++i ) {
        var aes = new asmCrypto.AES('0123456789ABCDEF');
        aes.asm.init_state.apply( aes.asm, aes_sub_shift_mix_vectors[i][0] );
        aes.asm._sub_shift_mix();
        ok(
            aes.asm._test_state.apply( aes.asm, aes_sub_shift_mix_vectors[i][1] ),
            "_sub_shift_mix vector " + i
        );
        aes.asm._inv_sub_shift_mix();
        ok(
            aes.asm._test_state.apply( aes.asm, aes_sub_shift_mix_vectors[i][0] ),
            "_inv_sub_shift_mix vector " + i
        );
    }
});

var aes_expand_key_vector = [
    [ 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c ],
    [ 0xa0, 0xfa, 0xfe, 0x17, 0x88, 0x54, 0x2c, 0xb1, 0x23, 0xa3, 0x39, 0x39, 0x2a, 0x6c, 0x76, 0x05 ],
    [ 0xf2, 0xc2, 0x95, 0xf2, 0x7a, 0x96, 0xb9, 0x43, 0x59, 0x35, 0x80, 0x7a, 0x73, 0x59, 0xf6, 0x7f ]
];

test( "_expand_key_128", function () {
    var aes = new asmCrypto.AES('0123456789ABCDEF');

    aes.asm.init_key_128.apply( aes.asm, aes_expand_key_vector[0] );
    aes.asm._expand_key_128();

    for ( var i = 1; i < aes_expand_key_vector.length; ++i ) {
        var args = [ i ]; args.push.apply( args, aes_expand_key_vector[i] );
        ok(
            aes.asm._test_key_128.apply( aes.asm, args ),
            "_expand_key_128 " + i
        );
    }
});

var aes_encrypt_vectors = [
    [ [ 0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34 ],
      [ 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c ],
      [ 0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32 ] ]
];

test( "_encrypt_128", function () {
    var aes = new asmCrypto.AES('0123456789ABCDEF');
    for ( var i = 0; i < aes_encrypt_vectors.length; ++i ) {
        aes.asm.init_state.apply( aes.asm, aes_encrypt_vectors[i][0] );
        aes.asm.init_key_128.apply( aes.asm, aes_encrypt_vectors[i][1] );
        aes.asm._expand_key_128();
        aes.asm._encrypt_128();
        ok(
            aes.asm._test_state.apply( aes.asm, aes_encrypt_vectors[i][2] ),
            "_encrypt_128 vector " + i
        );
    }
});

test( "_decrypt_128", function () {
    var aes = new asmCrypto.AES('0123456789ABCDEF');
    for ( var i = 0; i < aes_encrypt_vectors.length; ++i ) {
        aes.asm.init_state.apply( aes.asm, aes_encrypt_vectors[i][2] );
        aes.asm.init_key_128.apply( aes.asm, aes_encrypt_vectors[i][1] );
        aes.asm._expand_key_128();
        aes.asm._decrypt_128();
        ok(
            aes.asm._test_state.apply( aes.asm, aes_encrypt_vectors[i][0] ),
            "_decrypt_128 vector " + i
        );
    }
});

</script>
</body>
